var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions-List-1","page":"Functions List","title":"Functions List","text":"","category":"section"},{"location":"functions/#Language_Fundamentals-:-1","page":"Functions List","title":"Language_Fundamentals :","text":"","category":"section"},{"location":"functions/#","page":"Functions List","title":"Functions List","text":"<table>\n    <tr>\n        <td></td>\n        <td>Sub Package</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>1</td>\n        <td>Entering_Commands</td>\n        <td>clcM</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>Matrices_and_Arrays</td>\n        <td>zerosM, onesM, randM, trueM, falseM, eyeM, diagM, catM, horzcatM, vertcatM, repelemM(limited), repmatM, linspaceM, logspaceM, meshgridM, ndgridM, freqspaceM, lengthM, sizeM, numelM, isscalarM, isvectorM, flipM, fliplrM, flipudM, flipdimM, rot90M, transposeM, squeezeM</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>Data Types/Numeric Types</td>\n        <td>doubleM, singleM, int8M, int16M, int32M, int64M, uint8M, uint16M, uint32M, uint64M</td>\n    </tr>\n</table>","category":"page"},{"location":"functions/#","page":"Functions List","title":"Functions List","text":"","category":"page"},{"location":"functions/#","page":"Functions List","title":"Functions List","text":"To see the full progress see this link: here","category":"page"},{"location":"functions/#","page":"Functions List","title":"Functions List","text":"The full list of the functions that will be implemented in the future can be found Here","category":"page"},{"location":"juliavsmatlab/#Native-Julia-noteworthy-differences-from-MATLAB-1","page":"Native Julia noteworthy differences from MATLAB","title":"Native Julia noteworthy differences from MATLAB","text":"","category":"section"},{"location":"juliavsmatlab/#","page":"Native Julia noteworthy differences from MATLAB","title":"Native Julia noteworthy differences from MATLAB","text":"This package tries to minimize the differences between Julia and Matlab. However, for the record, these points are worth considering.","category":"page"},{"location":"juliavsmatlab/#","page":"Native Julia noteworthy differences from MATLAB","title":"Native Julia noteworthy differences from MATLAB","text":"From: https://docs.julialang.org/en/v1/manual/noteworthy-differences/index.html","category":"page"},{"location":"juliavsmatlab/#","page":"Native Julia noteworthy differences from MATLAB","title":"Native Julia noteworthy differences from MATLAB","text":"Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:","category":"page"},{"location":"juliavsmatlab/#Julia-Arrays:-1","page":"Native Julia noteworthy differences from MATLAB","title":"Julia Arrays:","text":"","category":"section"},{"location":"juliavsmatlab/#","page":"Native Julia noteworthy differences from MATLAB","title":"Native Julia noteworthy differences from MATLAB","text":"Julia arrays are indexed with square brackets, A[i,j].\nJulia has true one-dimensional arrays. Column vectors are of size N, not Nx1. For example, rand(N) makes a 1-dimensional array.\nIn Julia, to make an one-dimensional arrays,\nUse ; or , for concatenation. You can think of this as \"one-dimensional arrays in Julia are like vertical arrays in MATLAB\". So using ; is more intuitive.\nDon't use space  for concatenation, as spaces make two-dimensional arrays.\n[1; 2; 3]\n[1, 2, 3]\ngive one-dimensional arrays (think of it as vertical array in MATLAB):\n3-element Array{Int64,1}:\n 1\n 2\n 3\nAnd,\n[1 2 3]\ngives a two-dimensional array (horizontal):\n1×3 Array{Int64,2}:\n 1  2  3\nIn Julia, for multi-dimensional arrays\nUse space  between elements for horizontal concatenation.\nDon't use , for horizontal concatenation!\nUse ; for vertical concatenation.\nIn Julia, [x,y,z] will always construct a 3-element array containing x, y and z.\nTo concatenate in the first (\"vertical\") dimension use either vcat(x,y,z) or separate with semicolons ([x; y; z]).\nTo concatenate in the second (\"horizontal\") dimension use either hcat(x,y,z) or separate with spaces ([x y z]).\nTo construct block matrices (concatenating in the first two dimensions), use either hvcat or combine spaces and semicolons ([a b; c d]).","category":"page"},{"location":"juliavsmatlab/#","page":"Native Julia noteworthy differences from MATLAB","title":"Native Julia noteworthy differences from MATLAB","text":"Julia arrays are not copied when assigned to another variable. After A = B, changing elements of B will modify A as well.\nJulia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.\nJulia does not automatically grow arrays in an assignment statement. Whereas in MATLAB a(4) = 3.2 can create the array a = [0 0 0 3.2] and a(5) = 7 can grow it into a = [0 0 0 3.2 7], the corresponding Julia statement a[5] = 7 throws an error if the length of a is less than 5 or if this statement is the first use of the identifier a. Julia has push! and append!, which grow Vectors much more efficiently than MATLAB's a(end+1) = val.\nThe imaginary unit sqrt(-1) is represented in Julia as im, not i or j as in MATLAB.\nIn Julia, literal numbers without a decimal point (such as 42) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, julia> a = -1; 2^a throws a domain error, as the result is not an integer (see the FAQ entry on domain errors for details).\nIn Julia, multiple values are returned and assigned as tuples, e.g. (a, b) = (1, 2) or a, b = 1, 2. MATLAB's nargout, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.\nIn Julia, a:b and a:b:c construct AbstractRange objects. To construct a full vector like in MATLAB, use collect(a:b). Generally, there is no need to call collect though. An AbstractRange object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as range, or with iterators such as enumerate, and zip. The special objects can mostly be used as if they were normal arrays.\nFunctions in Julia return values from their last expression or the return keyword instead of listing the names of variables to return in the function definition (see The return Keyword for details).\nA Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.\nIn Julia, reductions such as sum, prod, and max are performed over every element of an array when called with a single argument, as in sum(A), even if A has more than one dimension.\nIn Julia, parentheses must be used to call a function with zero arguments, like in rand().\nJulia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. println or @printf can be used to print specific output.\nIn Julia, if A and B are arrays, logical comparison operations like A == B do not return an array of booleans. Instead, use A .== B, and similarly for the other boolean operators like <, >.\nIn Julia, the operators &, |, and ⊻ (xor) perform the bitwise operations equivalent to and, or, and xor respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of A equal to 1 or 2 use (A .== 1) .| (A .== 2)).\nIn Julia, the elements of a collection can be passed as arguments to a function using the splat operator ..., as in xs=[1,2]; f(xs...).\nJulia's svd returns singular values as a vector instead of as a dense diagonal matrix.\nIn Julia, ... is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.\nIn both Julia and MATLAB, the variable ans is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, ans is not set when Julia code is run in non-interactive mode.\nJulia's structs do not support dynamically adding fields at runtime, unlike MATLAB's classes. Instead, use a Dict.\nIn Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.\nIn MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression x(x>3) or in the statement x(x>3) = [] to modify x in-place. In contrast, Julia provides the higher order functions filter and filter!, allowing users to write filter(z->z>3, x) and filter!(z->z>3, x) as alternatives to the corresponding transliterations x[x.>3] and x = x[x.>3]. Using filter! reduces the use of temporary arrays.\nThe analogue of extracting (or \"dereferencing\") all elements of a cell array, e.g. in vertcat(A{:}) in MATLAB, is written using the splat operator in Julia, e.g. as vcat(A...).","category":"page"},{"location":"development/#Development-1","page":"Development - Contribution","title":"Development","text":"","category":"section"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"clone the project in your usual way, or using the following command which clones the project in .julia\\dev\\MatLang","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"] dev https://github.com/juliamatlab/MatLang","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"cd to cloned package. if you used dev command, run the following:","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"cd(\"$(homedir())\\\\.julia\\\\dev\\\\MatLang\")","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"Activate the package:","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"] activate .","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"Set developing variable to true in the files in test and usage folder.","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"developing = true","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"Set developing variable to false before committing (for a successful CI build).","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"The package uses Revise for quick testing without the need for restarting.","category":"page"},{"location":"development/#Contribution-Coding-Standard-1","page":"Development - Contribution","title":"Contribution - Coding Standard","text":"","category":"section"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"For coding standard please refer to Coding Standard. Feel free to contribute to this multi-field project. We need developers from different backgrounds to provide Matlab friendly API and wrappers.","category":"page"},{"location":"development/#","page":"Development - Contribution","title":"Development - Contribution","text":"Separate repositories are created for each toolbox. To provide fast and efficient wrappers please follow: https://docs.julialang.org/en/v1/manual/performance-tips/#Write-%22type-stable%22-functions-1","category":"page"},{"location":"functions/Entering_Commands/#Functions-1","page":"Entering Commands","title":"Functions","text":"","category":"section"},{"location":"functions/Entering_Commands/#Language-Fundamentals-1","page":"Entering Commands","title":"Language Fundamentals","text":"","category":"section"},{"location":"functions/Entering_Commands/#Entering_Commands-1","page":"Entering Commands","title":"Entering_Commands","text":"","category":"section"},{"location":"functions/Entering_Commands/#","page":"Entering Commands","title":"Entering Commands","text":"Modules = [MatLang]\nPages   = [\"Entering_Commands.jl\"]","category":"page"},{"location":"functions/Entering_Commands/#MatLang.clcM-Tuple{}","page":"Entering Commands","title":"MatLang.clcM","text":"clcM()\n\nClear Command Window. Works for any IDE or console.\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#Functions-1","page":"Matrices and Arrays","title":"Functions","text":"","category":"section"},{"location":"functions/Matrices_and_Arrays/#Language-Fundamentals-1","page":"Matrices and Arrays","title":"Language Fundamentals","text":"","category":"section"},{"location":"functions/Matrices_and_Arrays/#Matrices-and-Arrays-1","page":"Matrices and Arrays","title":"Matrices and Arrays","text":"","category":"section"},{"location":"functions/Matrices_and_Arrays/#","page":"Matrices and Arrays","title":"Matrices and Arrays","text":"Modules = [MatLang]\nPages   = [\"Matrices_and_Arrays.jl\"]","category":"page"},{"location":"functions/Matrices_and_Arrays/#MatLang.blkdiagM-Tuple","page":"Matrices and Arrays","title":"MatLang.blkdiagM","text":"blkdiagM(A1,A2,...)\n\nCreates a square matrix with A1,A2,... on the diagonal and the rest of the elements being 0. Works for both square and non-square matrices.\n\nblkdiagM(A1,A2,..., :obj)\n\nReturns the object itself if you want to use BlockDiagonals methods. use collect(obj) to get the array.\n\nExamples\n\n1 = 3 * ones(2, 2);\nA2 = 4 * ones(2, 2);\nA3 = rand(3, 3);\nmBlkdiag1 = blkdiagM(A1, A2, A3)\n\nmBlkdiag2 = blkdiagM(ones(2, 2), 2 * ones(2, 2)) # [ones(2, 2) zeros(2, 2); zeros(2, 2)  2 * ones(2, 2)]\n\nA1 = ones(2, 4);\nA2 = 2 * ones(3, 2);\nmBlkdiag3 = blkdiagM(A1, A2) # [ones(2,4) zeros(2,2); zeros(3,4) 2*ones(3,2)]\n\nmBlkdiag1obj = blkdiagM(:obj, A1, A2, A3)\n\nmBlkdiag2obj = blkdiagM(:obj, ones(2, 2), 2 * ones(2, 2)) # Block Diagonal object for [ones(2, 2) zeros(2, 2); zeros(2, 2)  2 * ones(2, 2)]\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.catM-Tuple{Integer,Vararg{Any,N} where N}","page":"Matrices and Arrays","title":"MatLang.catM","text":"catM(dim, A1, A2, ...)\n\nconcatenates A1, A2, … , An along dimension dim.\n\nExamples\n\nmCat1 = catM(1, ones(3, 3), zeros(3, 3)) # [ones(3, 3); zeros(3, 3)]\n\nmCat2 = catM(2, ones(3, 3), zeros(3, 3)) # [ones(3, 3) zeros(3, 3)]\n\nmCat3 = catM(1, ones(3, 3), zeros(3, 3), 2 * ones(3, 3)) # [ones(3, 3); zeros(3, 3); 2 * ones(3, 3)]\n\nmCat4 = catM(3, ones(2, 2, 2), zeros(2, 2, 2)) # [ones(2, 2, 2) zeros(2, 2, 2)]\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.eyeM-Tuple{Type,Integer,Integer}","page":"Matrices and Arrays","title":"MatLang.eyeM","text":"eyeM(dim)         # square dim*dim matrix\neyeM(Type, dim)    # square dim*dim matrix\neyeM(dim, like = anArray) # to make an array with similar type of anArray\neyeM(dim1, dim2)   # giving size as a separate input numbers\neyeM(Type, dim1, dim2)   # giving size as a separate input numbers\neyeM(dim1, dim2, like = anArray) # to make an array with similar type of anArray\neyeM(sizeAsTuple) # giving size as a Tuple\neyeM(Type, sizeAsTuple) # giving size as a Tuple\neyeM(sizeAsTuple, like = anArray) # to make an array with similar type of anArray\neyeM(sizeAsArray) # non-efficient Matlab way\neyeM(Type, sizeAsArray) # non-efficient Matlab way\neyeM(sizeAsArray, like = anArray) # to make an array with similar type of anArray\n\nCreates 2D Identity matrix (can be non-square matrix).\n\neyeM is 2-dimensional by the definition, so you don't need to pass :mat argument for getting a 2-dimensional matrix from eyeM(dim)\n\nExamples\n\nmEye0 = eyeM(2); # [1 0 0; 0 1 0]\n\nmEye1 = eyeM(2, 3); # [1 0 0; 0 1 0]\n\nmEye2 = eyeM(Int32, 2, 3); # [1 0 0; 0 1 0]\n\nmEye3 = eyeM(2, 3, like = zerosM(Int8, 2, 2))\n\nmEye4 = eyeM((2, 2))  # giving size as a Tuple. In Julia we use (2,2) instead of giving it as [2,2]\n\nmEye5 = eyeM(Int32, (2, 2))  # giving size as a Tuple. In Julia we use (2,2) instead of giving it as [2,2]\n\nmEye6 = eyeM([2, 2]) # non-efficient Matlab way\n\nmEye7 = eyeM(Int32, [2, 2]) # non-efficient Matlab way\n\ns1 = size(ones(2, 3)) # getting size from another matrix or calculation\nmEye8 = eyeM(s1)  # giving size as a variable (Tuple).\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.falseM-Tuple","page":"Matrices and Arrays","title":"MatLang.falseM","text":"falseM(:mat, dim)          # square dim*dim matrix\nfalseM(sizeAsArray) # non-efficient Matlab way\n\nreturns an array filled with false values.\n\nfalseM(dim) returns 1-dimensional array. To get a square matrix like in Matlab, pass :mat as the 1st argument.\n\nExamples\n\nmFalse0 = falseM(:mat, 2) # same as falses(2,2)\n\nmFalse1 = falseM(2) # same as falses(2)\n\nmFalse2 = falseM((2, 2)) # = falseM(2,2) # giving size as Tuple\n\nmFalse3 = falseM([2, 2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.flipM-Tuple{Any}","page":"Matrices and Arrays","title":"MatLang.flipM","text":"flipM(A)\n\nFlip elements of a vector Flip elements of an array along columns Flip a string\n\nflipM(A, dim)\n\nFlip elements of an array along specifed dim\n\nExamples\n\nsFlip1 = flipM(\"Hi\") # \"iH\"\n\nmFlip2 = flipM([1; 2; 3; 4]) #[4;3;2;1]\n\nmFlip3 = flipM([1 2; 3 4]) # flips every column: # [3 4; 1 2]\n\nmFlip4 = flipM([1 2; 3 4], 2) # flip along dims 2: #[2 1; 4 3]\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.flipdimM-Tuple{AbstractArray,Integer}","page":"Matrices and Arrays","title":"MatLang.flipdimM","text":"flipdimM(A, dim)\n\nSee flipM doc\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.fliplrM-Tuple{Any}","page":"Matrices and Arrays","title":"MatLang.fliplrM","text":"flipudM(A)\n\nFlip input up to down See flipM doc\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.freqspaceM","page":"Matrices and Arrays","title":"MatLang.freqspaceM","text":"freqspaceM(n, opt, dim = dimAsInteger)\n\nReturns the implied frequency range for equally spaced frequency responses.\n\nPass :whole when dim=1, to get m evenly spaced points around the whole unit circle.\n\nPass :meshgridM when dim=2, to get meshgrid of the frequency range.\n\nExamples\n\nmFreqspace1 = freqspaceM(10, dim = 1) # 0:0.2:1\n\nmFreqspace2 = freqspaceM(10, :whole, dim = 1) # 0:0.2:1.8\n\nm1Freqspace3, m2Freqspace3 = freqspaceM(10, dim = 2) # returns two -1:0.2:0.8\n\nm1Freqspace4, m2Freqspace4 = freqspaceM(10, :meshgrid, dim = 2) # returns mesgridM(-1:0.2:0.8, -1:0.2:0.8), which is two -1:0.2:0.8\n\n\n\n\n\n","category":"function"},{"location":"functions/Matrices_and_Arrays/#MatLang.horzcatM","page":"Matrices and Arrays","title":"MatLang.horzcatM","text":"horzcatM(A1, A2, …)\n\nConcatenate arrays horizontally\n\nExamples\n\nmHCat1 = horzcatM(ones(3, 3), zeros(3, 3)) # [ones(3, 3) zeros(3, 3)]\n\n\n\n\n\n","category":"function"},{"location":"functions/Matrices_and_Arrays/#MatLang.isscalarM-Union{Tuple{T}, Tuple{T}} where T","page":"Matrices and Arrays","title":"MatLang.isscalarM","text":"isscalarM(x)\nisscalarM(:mat, x)\n\nReturns boolean true if x is scalar.\n\nIt uses Broadcast.DefaultArrayStyle{0}, which basically are numbers (0-dimensional) and 1 dimensional-1 element number arrays.\n\nTo get a MATLAB way result, pass :mat argument. Doing this:\n\nFor arrays (of any element type), it calculates number of elements (using numelM).\nFor single strings it calculates number of characters (using numelM).\nFor others, if it is among {Number,Char,Bool}, then it is considered scalar.\n\nExamples\n\nbIsscalar1 = isscalarM(1) # true\n\nbIsscalar2 = isscalarM(5 * ones(1, 1, 1)) # false\n\n# bIsscalar3 = isscalarM(\"H\") # gives error\n#\n# bIsscalar4 = isscalarM(\"Hi\") # gives error\n\nbIsscalar5 = isscalarM([\"Hi\"]) # false\n\nbIsscalar6 = isscalarM([\"Hi\" \"Bye\"]) # false\n\nbIsscalar7 = isscalarM('H') # true # becareful that in Julia, chars are always singular.\n\nbIsscalar8 = isscalarM(true) # true\n\n# Matlab way:\nbIsscalarMat1 = isscalarM(:mat, 1) # true\n\nbIsscalarMat2 = isscalarM(:mat, [1]) # true\n\nbIsscalarMat3 = isscalarM(:mat, 5 * ones(1, 1, 1)) # true\n\nbIsscalarMat4 = isscalarM(:mat, \"H\") # true\n\nbIsscalarMat5 = isscalarM(:mat, \"Hi\") # false\n\nbIsscalarMat6 = isscalarM(:mat, [\"Hi\"]) # true\n\nbIsscalarMat7 = isscalarM(:mat, [\"Hi\" \"Bye\"]) # false\n\nbIsscalarMat8 = isscalarM(:mat, 'H') # true # becareful that in Julia, chars are always singular.\n\nbIsscalarMat9 = isscalarM(:mat, true) # true\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.isvectorM-Tuple{Any}","page":"Matrices and Arrays","title":"MatLang.isvectorM","text":"isvectorM(x)\n\nReturns boolean true if x is a vector.\n\nIt uses AbstractVector, which basically are 1 dimensional arrays.\n\nTo get a MATLAB way result, pass :mat argument. Doing this:\n\nFor arrays (of any element type), it considers 1-dimensional arrays and also 2-dimensional arrays that one of their dimensions are singletone.\nFor others, if it is among {Number, AbstractString, Char, Bool}, then it is considered vectir.\n\nExamples\n\nA1 = [1; 2; 3] # or [1, 2, 3]\nbIsvector1 = isvectorM(A1) # true\n\nA2 = [1 2 3]\nbIsvector2 = isvectorM(A2) # false\n\nbIsvector3 = isvectorM(ones(3, 1)) # false\n\nbIsvector4 = isvectorM(ones(1, 3)) # false\n\nbIsvector5 = isvectorM(ones(3)) # true\n\nbIsvector6 = isvectorM(\"Hi\") # false\n\n# Matlab Way:\nbIsvector7 = isvectorM([\"Hi\", \"Bye\"]) # true\n\nbIsvectorMat1 = isvectorM(:mat, A1) # true\n\nbIsvectorMat2 = isvectorM(:mat, A2) # true\n\nbIsvectorMat3 = isvectorM(:mat, ones(3, 1)) # true\n\nbIsvectorMat4 = isvectorM(:mat, ones(1, 3)) # true\n\nbIsvectorMat5 = isvectorM(:mat, ones(3)) # true\n\nbIsvectorMat6 = isvectorM(:mat, \"Hi\") # true\n\nbIsvectorMat7 = isvectorM(:mat, [\"Hi\", \"Bye\"]) # true\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.lengthM-Tuple{AbstractArray}","page":"Matrices and Arrays","title":"MatLang.lengthM","text":"lengthM(A)\n\nLength of the largest array dimension of A.\n\nExamples\n\nA1 = [2 3 4 5 6 7;\n      1 2 3 4 5 6]\nnLength1 = lengthM(A1); # 6\n\nA2 = [\"Hi\" 6;\n      \"Goodbye\" 5;\n      \"Hello\" 1]\nnLength2 = lengthM(A2); # 3\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.linspaceM-Tuple{Any,Any}","page":"Matrices and Arrays","title":"MatLang.linspaceM","text":"linspaceM(start, stop)\nlinspaceM(start, stop, step)\nlinspaceM(:arr, start, stop)\nlinspaceM(:arr, start, stop, step)\n\nGenerate linearly spaced range. You can also write this as start:stop or start:step:stop.\n\nTo get the full vector isntead of a range object pass :arr as the 1st argument.\n\nExamples\n\nmLinspace1 = linspaceM(1, 10) # 1:10\n\nmLinspace2 = linspaceM(1, 10, 2) # 1:2:10 == 1:2:9\n\nmLinspace3 = linspaceM(:arr, 1, 10) # collect(1:10)\n\nmLinspace4 = linspaceM(:arr, 1, 10, 2) # collect(1:2:10)\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.logspaceM-Tuple{Any,Any}","page":"Matrices and Arrays","title":"MatLang.logspaceM","text":"logspaceM(start, stop) # gives 50 points\nlogspaceM(start, stop, length)\nlogspaceM(start, stop, :equal) # equally spaced powers of 10\n\nGenerate logarithmically spaced vector (between 10^start and 10^stop). length is the number of the poinst (50 by defualt if not supplied). If you instead provide :equal, it makes a range from equally spaced powers of 10\n\nFor logspaceM in contrast to linspaceM, the full vector is given by default.\n\nExamples\n\nmLogspace1 = logspaceM(1, 5) # 50 logarithmically spaced points between 10^1 and 10^5\n\nmLogspace2 = logspaceM(1, 5, 10) # 10 logarithmically spaced points between 10^1 and 10^5\n\nmLogspace3 = logspaceM(1, 5, :equal) # [10.0^1, 10.0^2, 10.0^3, 10.0^4, 10.0^5] == 10.0.^(1:5)\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.meshgridM-Tuple{AbstractArray{T,1} where T}","page":"Matrices and Arrays","title":"MatLang.meshgridM","text":"meshgridM(vx)\nmeshgridM(vx,vy)\nmeshgridM(vx,vy,vz)\n\nCreates a 2-dimensional or 3-dimensional rectangular grid, that spans the space made by it.\n\nmeshgridM(vx) computes a 2-D (x,y)-grid from the vectors (vx,vx).\n\nmeshgridM(vx,vy) computes a 2-D (x,y)-grid from the vectors (vx,vy).\n\nmeshgridM(vx,vy,vz) computes a 3-D (x,y,z)-grid from the vectors (vx,vy,vz).\n\nmeshgridM's 1st output is the transpose of ngridsM's 1st output. It is the same for the 2nd output.\n\nModified from https://github.com/ChrisRackauckas/VectorizedRoutines.jl/blob/master/src/matlab.jl\n\nExamples\n\nm1Meshgrid0, m2Meshgrid0 = meshgridM(1:2:5) # a 2-D rectangle spanning 1:2:5 in x and y direction == [[1;1;1][3;3;3] [5;5;5]] and [1 1 1; 3 3 3; 5 5 5]\n\nm1Meshgrid1, m2Meshgrid1 = meshgridM(1:2:5, 1:2:5) #  a 2-D rectangle spanning 1:2:5 in x and y direction == ([1 3 5;1 3 5; 1 3 5],[1 1 1; 3 3 3; 5 5 5])\n\nm1Meshgrid2, m2Meshgrid2, m3Meshgrid2 = meshgridM(1:6, 20:25, 5:10) # a 3-D rectangle spanning 1:6 in x, 20:25 in y, and 5:10 in z\n\n\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.ndgridM-Tuple{AbstractArray{T,1} where T}","page":"Matrices and Arrays","title":"MatLang.ndgridM","text":"ngridM(x1, x2,...)\nngridM(x, dim = dimAsInteger)\n\nCreates a N-dimensional rectangular grid, that spans the space made by it.\n\nIn ngridM(x1, x2,...), depending on the number of inputs, the dimension of output grid is specified.\n\nIn ngridM(x, dim = dimAsInteger), user should explicitly pass the dimension as an integer to the function.\n\nngridsM's 1st output is the transpose of meshgridM()'s 1st output. It is the same for the 2nd output.\n\nModified from https://github.com/ChrisRackauckas/VectorizedRoutines.jl/blob/master/src/matlab.jl\n\nExamples\n\nm1Ndgrid0, m2Ndgrid0 = ndgridM(1:2:5, dim = 2) # a 2-D rectangle spanning 1:2:5 in x and y direction == [1 1 1; 3 3 3; 5 5 5] and [1 3 5;1 3 5; 1 3 5]\n\nm1Ndgrid1, m2Ndgrid1 = ndgridM(1:2:5, 1:2:5) #  a 2-D rectangle spanning 1:2:5 in x and y direction == ([1 1 1; 3 3 3; 5 5 5], [1 3 5;1 3 5; 1 3 5])\n\nm1Ndgrid2, m2Ndgrid2, m3Ndgrid2 = ndgridM(1:6, 20:25, 5:10) # a 3-D rectangle spanning 1:6 in x, 20:25 in y, and 5:10 in z\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.ndimsM","page":"Matrices and Arrays","title":"MatLang.ndimsM","text":"ndimsM(A)\n\nReturn the number of dimensions of A.\n\nIn contrast to Matlab equivalent, this function considers trailing singleton dimensions,\n\nConsider the points that are explained here when using this function: Julia Arrays\n\nExamples\n\nA = rand(3,4,5);\nnDim1 = ndims(A) # 3\n\n\n\n\n\n","category":"function"},{"location":"functions/Matrices_and_Arrays/#MatLang.numelM","page":"Matrices and Arrays","title":"MatLang.numelM","text":"numelM(A)\n\nReturns the number of elements of array A.\n\nExamples\n\nnNumel1 = numelM(1:5) # 5\n\nnNumel2 = numelM([1, 2, 3, 4]) # 4\n\nnNumel3 = numelM([1 2; 3 4]) # 4\n\n\n\n\n\n","category":"function"},{"location":"functions/Matrices_and_Arrays/#MatLang.onesM-Tuple","page":"Matrices and Arrays","title":"MatLang.onesM","text":"onesM(:mat, dim)         # square dim*dim matrix\nonesM(:mat, Type,dim)    # square dim*dim matrix\nonesM(:mat, dim, like=anArray) # to make an array with similar type of anArray\nonesM(sizeAsArray) # non-efficient Matlab way\nonesM(Type, sizeAsArray) # non-efficient Matlab way\nonesM(sizeAsArray, like=anArray) # to make an array with similar type of anArray\n\nreturns an array filled with one values.\n\nonesM(dim) returns 1-dimensional array. To get a square matrix like in Matlab, pass :mat as the 1st argument.\n\nExamples\n\nmOnes0 = onesM(:mat, 2) # same as ones(2,2)\n\nmOnes1 = onesM(:mat, 2, like = zerosM(Int32, 2, 2)) # like method\n\nmOnes2 = onesM(2) # same as ones(2)\n\nmOnes3 = onesM(Int32, 2, 2) # same as ones(Int32,2,2)\n\nmOnes4 = onesM((2, 2)) # = onesM(2,2) # giving size as Tuple\n\nmOnes5 = onesM(Int32, (2, 2)) # giving size as Tuple and also the Int32 type\n\nmOnes6 = onesM([2, 2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.\n\nmOnes7 = onesM(Int32, [2, 2]) # giving size as Array, non-efficient Matlab way\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.randM-Tuple","page":"Matrices and Arrays","title":"MatLang.randM","text":"randM(:mat, dim)          # square dim*dim matrix\nrandM(:mat, Type, dim)    # square dim*dim matrix\nrandM(:mat, dim, like = anArray) # to make an array with similar type of anArray\nrandM(sizeAsArray) # non-efficient Matlab way\nrandM(Type, sizeAsArray) # non-efficient Matlab way\nrandM(sizeAsArray, like = anArray) # to make an array with similar type of anArray\n\nreturns an array filled with random values.\n\nrandM(dim) returns 1-dimensional array. To get a square matrix like in Matlab, pass :mat as the 1st argument.\n\nExamples\n\nmRand0 = randM(:mat, 2) # same as rand(2,2)\n\nmRand1 = randM(:mat, 2, like = zerosM(Int32, 2, 2)) # like method\n\nmRand2 = randM(2) # same as rand(2)\n\nmRand3 = randM(Int32, 2, 2) # same as rand(Int32,2,2)\n\nmRand4 = randM((2, 2)) # = randM(2,2) # giving size as Tuple\n\nmRand5 = randM(Int32, (2, 2)) # giving size as Tuple and also the Int32 type\n\nmRand6 = randM([2, 2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.\n\nmRand7 = randM(Int32, [2, 2]) # giving size as Array, non-efficient Matlab way\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.repelemM-Tuple{AbstractArray,Integer}","page":"Matrices and Arrays","title":"MatLang.repelemM","text":"repelemM(V, count)\n\nConstruct an array by repeating elements of array V by a given number of times specified by counts. if If count is a scalar, then each element of V is repeated count times\n\nExamples\n\nV1 = [1 2 3 4];\nmRepelem1 = repelemM(V1, 3) # [1 1 1 2 2 2 3 3 3 4 4 4]\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.repmatM-Tuple{AbstractArray,Integer}","page":"Matrices and Arrays","title":"MatLang.repmatM","text":"repmatM(A, n) # n*n copy\nrepmatM(A, s1, s2, ...)\nrepmatM(A, [s1, s2, ...])\nrepmatM(A, (s1, s2, ...))\n\nRepeat copies of array A based on the give size\n\nExamples\n\nmRempat1 = repmatM(10, 3, 2) # [10 10; 10 10; 10 10]\n\nV = [1; 2]\nmRempat2 = repmatM(V, 3, 2)   # [[1; 2] [1; 2]; [1; 2] [1; 2]; [1; 2] [1; 2]]\n\nmRempat3 = repmatM(V, [3, 2]) # [[1; 2] [1; 2]; [1; 2] [1; 2]; [1; 2] [1; 2]]\n\nmRempat4 = repmatM(V, (3, 2)) # [[1; 2] [1; 2]; [1; 2] [1; 2]; [1; 2] [1; 2]]\n\nmRempat5 = repmatM(V, 2) # [[1; 2] [1; 2]; [1; 2] [1; 2]]\n\nmRempat6 = repmatM(V, 1, 3) # [[1; 2] [1; 2] [1; 2]]\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.rot90M","page":"Matrices and Arrays","title":"MatLang.rot90M","text":"rot90M(A)\nrot90M(A, k)\n\nRotate 90 or 90*k degress counter clock wise.\n\nExamples\n\nmRot1 = rot90M([1 2; 3 4]) #[2 4; 1 3]\n\nmRot2 = rot90M([1 2; 3 4], 3) # [3 1; 4 2]\n\n\n\n\n\n","category":"function"},{"location":"functions/Matrices_and_Arrays/#MatLang.sizeM-Tuple","page":"Matrices and Arrays","title":"MatLang.sizeM","text":"sizeAsTuple = sizeM(A)\nsizeDim = sizeM(dim)  # only returns the specified dim\nsizeDimAsTuple = sizeM(A, dim1, dim2,...) # only returns the specified dims\nsizeAsArray = sizeM(:arr, A)\nsizeDimAsArray = sizeM(:arr, A, dim1, dim2,...) # only returns the specified dims\nsz1, sz2, ... = size(A)\n\nReturns the size of an array as a Tuple.\n\nPass :arr to get size as an Array (not a Tuple).\n\nConsider the points that are explained here when using this function: Julia Arrays\n\nExamples\n\nA1 = [2 3 4 5 6 7;\n      1 2 3 4 5 6]\nmSize1 = sizeM(:arr, A1); # [2; 6]\ntSize1 = sizeM(A1); # (2, 6)\n\nnA1Size2 = sizeM(A1, 2); # 6\nsizeM(A1, 2) == 6 # true\nsizeM(:arr, A1, 2) == 6 # false\nsizeM(:arr, A1, 2) == [6] # true\n\nnA1Size1, nA1Size2 = sizeM(A1); # 2 and 6\n\nA2 = rand(3, 5, 4)\nmSize2 = sizeM(:arr, A2, 2, 3); # [5; 4]\ntSize2 = sizeM(A2, 2, 3); # (5, 4)\n\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.squeezeM-Tuple{AbstractArray}","page":"Matrices and Arrays","title":"MatLang.squeezeM","text":"squeezeM(A)\n\nDrops all of the singleton dimensions of A (dimensions that are 1). If A contains only one element (i.e., all of its dimensions are singletons) then the output will be a zero-dimensional array.\n\nIf you know the dimension that you want to drop, use dropdims(A ; dims= dimensionsToRemove).\n\nOnly use this function if you don't know the dimensions that you want to remove, and you are sure that you are not removing important dimensions, and if you don't care about type stability.\n\nReturns an array containing the same data as A but with no singleton dimensions; note that the output is NOT a copy of A, i.e., modifying the contents of output will modify the contents of A. To get a copy use copy(output).\n\nExamples\n\nA1 = ones(2, 1, 2); # 3 dimensional\nmSqueeze1 = squeezeM(A1) # [1 1; 1 1]\n\nA2 = zeros(1, 4, 1);\nA2[:, 1:4, ] = [5; 3; 6; 0]\nmSqueeze2 = squeezeM(A2) # When it gets one dimensional, it is vertical.\n\nmSqueeze2 == [5; 3; 6; 0] # true\nmSqueeze2 == [5 3 6 0] # false\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.transposeM-Tuple","page":"Matrices and Arrays","title":"MatLang.transposeM","text":"transposeM(A)\ntransposeM(:arr, A)\n\nReturns the transpose an array.\n\nIf :arr is supplied permutedims method is used which returns an array rather a transpose object.\n\nYou can use ' for transposing an Array (e.g A'), the result is an adjoint object. If you want, you can get the array using collect(). Be careful that in Julia .' is not used for transposing.\n\nExamples\n\nA1 = [2 3 4 5 6 7;\n      1 2 3 4 5 6]\nmTranspose1 = transposeM(A1)\n\nmTranspose2 = transposeM(:arr, A1)\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.trueM-Tuple","page":"Matrices and Arrays","title":"MatLang.trueM","text":"trueM(:mat, dim)          # square dim*dim matrix\ntrueM(sizeAsArray) # non-efficient Matlab way\n\nreturns an array filled with true values.\n\ntrueM(dim) returns 1-dimensional array. To get a square matrix like in Matlab, pass :mat as the 1st argument.\n\nExamples\n\nmTrue0 = trueM(:mat, 2) # same as trues(2,2)\n\nmTrue1 = trueM(2) # same as trues(2)\n\nmTrue2 = trueM((2, 2)) # = trues(2,2) # giving size as Tuple\n\nmTrue3 = trueM([2, 2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.\n\n\n\n\n\n","category":"method"},{"location":"functions/Matrices_and_Arrays/#MatLang.vertcatM","page":"Matrices and Arrays","title":"MatLang.vertcatM","text":"vertcatM(A1, A2, …)\n\nConcatenate arrays vertically\n\nExamples\n\nmVCat1 = vertcatM(ones(3, 3), zeros(3, 3)) # [ones(3, 3); zeros(3, 3)]\n\n\n\n\n\n","category":"function"},{"location":"functions/Matrices_and_Arrays/#MatLang.zerosM-Tuple","page":"Matrices and Arrays","title":"MatLang.zerosM","text":"zerosM(:mat, dim)         # square dim*dim matrix\nzerosM(:mat, Type,dim)    # square dim*dim matrix\nzerosM(:mat, dim, like=anArray) # to make an array with similar type of anArray\nzerosM(sizeAsArray) # non-efficient Matlab way\nzerosM(Type, sizeAsArray) # non-efficient Matlab way\nzerosM(sizeAsArray, like=anArray) # to make an array with similar type of anArray\n\nreturns an array filled with zero values.\n\nzerosM(dim) returns 1-dimensional array. To get a square matrix like in Matlab, pass :mat as the 1st argument.\n\nExamples\n\nmZeros0 = zerosM(:mat, 2) # same as zeros(2,2)\n\nmZeros1 = zerosM(:mat, 2, like = zerosM(Int32, 2, 2)) # like method\n\nmZeros2 = zerosM(2) # same as zeros(2)\n\nmZeros3 = zerosM(Int32, 2, 2) # same as zeros(Int32,2,2)\n\nmZeros4 = zerosM((2, 2)) # = zerosM(2,2) # giving size as Tuple\n\nmZeros5 = zerosM(Int32, (2, 2)) # giving size as Tuple and also the Int32 type\n\nmZeros6 = zerosM([2, 2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.\n\nmZeros7 = zerosM(Int32, [2, 2]) # giving size as Array, non-efficient Matlab way\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Home","title":"Home","text":"# Information for Documenter\nCurrentModule = MatLang","category":"page"},{"location":"#MatLang-Documentation-1","page":"Home","title":"MatLang Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"API for Matlab's language core functions","category":"page"},{"location":"#","page":"Home","title":"Home","text":"MatLang GitHub Repository Link: [MatLang]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JuliaMatlab GitHub Repository Link: [JuliaMatlab Organization], [Master Repo]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Dev Doc) (Image: Project Status: Active – The project has reached a stable, usable state and is being actively developed.) (Image: Build Status) (Image: Build status) (Image: codecov)","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Add the package","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add https://github.com/juliamatlab/MatLang","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Use the package:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using MatLang","category":"page"},{"location":"#Table-of-contents-1","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"functions.md\", \"development.md\", \"juliavsmatlab.md\"]","category":"page"},{"location":"functions/Numeric_Types/#Functions-1","page":"Numeric Types","title":"Functions","text":"","category":"section"},{"location":"functions/Numeric_Types/#Language-Fundamentals-1","page":"Numeric Types","title":"Language Fundamentals","text":"","category":"section"},{"location":"functions/Numeric_Types/#Data-Types-/-Numeric-Types-1","page":"Numeric Types","title":"Data Types / Numeric Types","text":"","category":"section"},{"location":"functions/Numeric_Types/#","page":"Numeric Types","title":"Numeric Types","text":"Modules = [MatLang]\nPages   = [\"Numeric_Types.jl\"]","category":"page"},{"location":"functions/Numeric_Types/#MatLang.doubleM-Tuple{Any}","page":"Numeric Types","title":"MatLang.doubleM","text":"doubleM(x)\n\nConverts to Float64 type.\n\nExamples\n\nnFloat1 = doubleM(12.0)\nt1 = typeof(nFloat1) # Float64\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.int16M-Tuple{Any}","page":"Numeric Types","title":"MatLang.int16M","text":"int16M(x)\n\nConverts to Int16 type.\n\nExamples\n\nnInt2 = int16M(-10)\nt4 = typeof(nInt2) # Int16\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.int32M-Tuple{Any}","page":"Numeric Types","title":"MatLang.int32M","text":"int32M(x)\n\nConverts to Int32 type.\n\nExamples\n\nnInt3 = int32M(-10)\nt5 = typeof(nInt3) # Int32\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.int64M-Tuple{Any}","page":"Numeric Types","title":"MatLang.int64M","text":"int64M(x)\n\nConverts to Int64 type.\n\nExamples\n\nnInt4 = int64M(-10)\nt6 = typeof(nInt4) # Int64\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.int8M-Tuple{Any}","page":"Numeric Types","title":"MatLang.int8M","text":"int8M(x)\n\nConverts to Int8 type.\n\nExamples\n\nnInt1 = int8M(-10)\nt3 = typeof(nInt1) # Int8\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.singleM-Tuple{Any}","page":"Numeric Types","title":"MatLang.singleM","text":"singleM(x)\n\nConverts to Float32 type.\n\nExamples\n\nnFloat2 = singleM(12.0)\nt2 = typeof(nFloat2) # Float32\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.uint16M-Tuple{Any}","page":"Numeric Types","title":"MatLang.uint16M","text":"uint16M(x)\n\nConverts to UInt16 type.\n\nExamples\n\nnUInt2 = uint16M(10)\nt8 = typeof(nUInt2) # UInt16\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.uint32M-Tuple{Any}","page":"Numeric Types","title":"MatLang.uint32M","text":"uint32M(x)\n\nConverts to UInt32 type.\n\nExamples\n\nnUInt3 = uint32M(10)\nt9 = typeof(nUInt3) # UInt32\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.uint64M-Tuple{Any}","page":"Numeric Types","title":"MatLang.uint64M","text":"uint64M(x)\n\nConverts to UInt64 type.\n\nExamples\n\nnUInt4 = uint64M(10)\nt10 = typeof(nUInt4) # UInt64\n\n\n\n\n\n","category":"method"},{"location":"functions/Numeric_Types/#MatLang.uint8M-Tuple{Any}","page":"Numeric Types","title":"MatLang.uint8M","text":"uint8M(x)\n\nConverts to UInt8 type.\n\nExamples\n\nnUInt1 = uint8M(10)\nt7 = typeof(nUInt1) # UInt8\n\n\n\n\n\n","category":"method"}]
}
