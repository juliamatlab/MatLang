<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrices and Arrays · MatLang</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MatLang logo"/></a><div class="docs-package-name"><span class="docs-autofit">MatLang</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../">Functions List</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Functions Explanations and Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Entering_Commands/">Entering Commands</a></li><li class="is-active"><a class="tocitem" href>Matrices and Arrays</a></li><li><a class="tocitem" href="../Numeric_Types/">Numeric Types</a></li></ul></li></ul></li><li><a class="tocitem" href="../../development/">Development - Contribution</a></li><li><a class="tocitem" href="../../juliavsmatlab/">Native Julia noteworthy differences from MATLAB</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Functions Explanations and Examples</a></li><li class="is-active"><a href>Matrices and Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrices and Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliamatlab/MatLang/blob/master/docs/src/functions/Matrices_and_Arrays.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h1><h3 id="Language-Fundamentals-1"><a class="docs-heading-anchor" href="#Language-Fundamentals-1">Language Fundamentals</a><a class="docs-heading-anchor-permalink" href="#Language-Fundamentals-1" title="Permalink"></a></h3><h4 id="Matrices-and-Arrays-1"><a class="docs-heading-anchor" href="#Matrices-and-Arrays-1">Matrices and Arrays</a><a class="docs-heading-anchor-permalink" href="#Matrices-and-Arrays-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="MatLang.blkdiagM-Tuple" href="#MatLang.blkdiagM-Tuple"><code>MatLang.blkdiagM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blkdiagM(A1,A2,...)</code></pre><p>Creates a square matrix with A1,A2,... on the diagonal and the rest of the elements being 0. Works for both square and non-square matrices.</p><pre><code class="language-none">blkdiagM(A1,A2,..., :obj)</code></pre><p>Returns the object itself if you want to use BlockDiagonals methods. use <code>collect(obj)</code> to get the array.</p><p><strong>Examples</strong></p><pre><code class="language-julia">1 = 3 * ones(2, 2);
A2 = 4 * ones(2, 2);
A3 = rand(3, 3);
mBlkdiag1 = blkdiagM(A1, A2, A3)

mBlkdiag2 = blkdiagM(ones(2, 2), 2 * ones(2, 2)) # [ones(2, 2) zeros(2, 2); zeros(2, 2)  2 * ones(2, 2)]

A1 = ones(2, 4);
A2 = 2 * ones(3, 2);
mBlkdiag3 = blkdiagM(A1, A2) # [ones(2,4) zeros(2,2); zeros(3,4) 2*ones(3,2)]

mBlkdiag1obj = blkdiagM(:obj, A1, A2, A3)

mBlkdiag2obj = blkdiagM(:obj, ones(2, 2), 2 * ones(2, 2)) # Block Diagonal object for [ones(2, 2) zeros(2, 2); zeros(2, 2)  2 * ones(2, 2)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL259-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.catM-Tuple{Integer,Vararg{Any,N} where N}" href="#MatLang.catM-Tuple{Integer,Vararg{Any,N} where N}"><code>MatLang.catM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">catM(dim, A1, A2, ...)</code></pre><p>concatenates A1, A2, … , An along dimension dim.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mCat1 = catM(1, ones(3, 3), zeros(3, 3)) # [ones(3, 3); zeros(3, 3)]

mCat2 = catM(2, ones(3, 3), zeros(3, 3)) # [ones(3, 3) zeros(3, 3)]

mCat3 = catM(1, ones(3, 3), zeros(3, 3), 2 * ones(3, 3)) # [ones(3, 3); zeros(3, 3); 2 * ones(3, 3)]

mCat4 = catM(3, ones(2, 2, 2), zeros(2, 2, 2)) # [ones(2, 2, 2) zeros(2, 2, 2)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL319-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.eyeM-Tuple{Type,Integer,Integer}" href="#MatLang.eyeM-Tuple{Type,Integer,Integer}"><code>MatLang.eyeM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eyeM(dim)         # square dim*dim matrix
eyeM(Type, dim)    # square dim*dim matrix
eyeM(dim, like = anArray) # to make an array with similar type of anArray
eyeM(dim1, dim2)   # giving size as a separate input numbers
eyeM(Type, dim1, dim2)   # giving size as a separate input numbers
eyeM(dim1, dim2, like = anArray) # to make an array with similar type of anArray
eyeM(sizeAsTuple) # giving size as a Tuple
eyeM(Type, sizeAsTuple) # giving size as a Tuple
eyeM(sizeAsTuple, like = anArray) # to make an array with similar type of anArray
eyeM(sizeAsArray) # non-efficient Matlab way
eyeM(Type, sizeAsArray) # non-efficient Matlab way
eyeM(sizeAsArray, like = anArray) # to make an array with similar type of anArray</code></pre><p>Creates 2D Identity matrix (can be non-square matrix).</p><p>eyeM is 2-dimensional by the definition, so you don&#39;t need to pass <code>:mat</code> argument for getting a 2-dimensional matrix from <code>eyeM(dim)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia">mEye0 = eyeM(2); # [1 0 0; 0 1 0]

mEye1 = eyeM(2, 3); # [1 0 0; 0 1 0]

mEye2 = eyeM(Int32, 2, 3); # [1 0 0; 0 1 0]

mEye3 = eyeM(2, 3, like = zerosM(Int8, 2, 2))

mEye4 = eyeM((2, 2))  # giving size as a Tuple. In Julia we use (2,2) instead of giving it as [2,2]

mEye5 = eyeM(Int32, (2, 2))  # giving size as a Tuple. In Julia we use (2,2) instead of giving it as [2,2]

mEye6 = eyeM([2, 2]) # non-efficient Matlab way

mEye7 = eyeM(Int32, [2, 2]) # non-efficient Matlab way

s1 = size(ones(2, 3)) # getting size from another matrix or calculation
mEye8 = eyeM(s1)  # giving size as a variable (Tuple).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL173-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.falseM" href="#MatLang.falseM"><code>MatLang.falseM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">falseM</code></pre><p>returns an array filled with false values.</p><p>In addition to original Julia methods the following methods are provided:</p><pre><code class="language-none">falseM(sizeAsArray)</code></pre><p>To give size as an array (non-efficient Matlab way).</p><pre><code class="language-none">falseM(:mat, dim)         # square dim*dim matrix</code></pre><p><code>falseM(dim)</code> returns 1-dimensional array. To get a square matrix like in Matlab, pass <code>:mat</code> as the 1st argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mfalse0 = falseM(:mat, 2) # same as falses(2,2)

mfalse1 = falseM(2) # same as falses(2)

# giving size as Tuple
mfalse2 = falseM((2, 2)) # = falses(2,2)

# giving size as an Array
## non-efficient Matlab way. Array should be Integer otherwise you will get errors.
mfalse3 = falseM([2, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL127-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.flipM-Tuple{Any}" href="#MatLang.flipM-Tuple{Any}"><code>MatLang.flipM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flipM(A)</code></pre><p>Flip elements of a vector Flip elements of an array along columns Flip a string</p><pre><code class="language-none">flipM(A, dim)</code></pre><p>Flip elements of an array along specifed dim</p><p><strong>Examples</strong></p><pre><code class="language-julia">sFlip1 = flipM(&quot;Hi&quot;) # &quot;iH&quot;

mFlip2 = flipM([1; 2; 3; 4]) #[4;3;2;1]

mFlip3 = flipM([1 2; 3 4]) # flips every column: # [3 4; 1 2]

mFlip4 = flipM([1 2; 3 4], 2) # flip along dims 2: #[2 1; 4 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1163-L1184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.flipdimM-Tuple{AbstractArray,Integer}" href="#MatLang.flipdimM-Tuple{AbstractArray,Integer}"><code>MatLang.flipdimM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flipdimM(A, dim)</code></pre><p>See <a href="#MatLang.flipM-Tuple{Any}"><code>flipM</code></a> doc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1206-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.fliplrM-Tuple{Any}" href="#MatLang.fliplrM-Tuple{Any}"><code>MatLang.fliplrM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fliplrM(A)</code></pre><p>Flip input left to right See <a href="#MatLang.flipM-Tuple{Any}"><code>flipM</code></a> doc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1188-L1193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.flipudM-Tuple{Any}" href="#MatLang.flipudM-Tuple{Any}"><code>MatLang.flipudM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flipudM(A)</code></pre><p>Flip input up to down See <a href="#MatLang.flipM-Tuple{Any}"><code>flipM</code></a> doc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1197-L1202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.freqspaceM" href="#MatLang.freqspaceM"><code>MatLang.freqspaceM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">freqspaceM(n, opt, dim = dimAsInteger)</code></pre><p>Returns the implied frequency range for equally spaced frequency responses.</p><p>Pass <code>:whole</code> when dim=1, to get m evenly spaced points around the whole unit circle.</p><p>Pass <code>:meshgridM</code> when dim=2, to get meshgrid of the frequency range.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mFreqspace1 = freqspaceM(10, dim = 1) # 0:0.2:1

mFreqspace2 = freqspaceM(10, :whole, dim = 1) # 0:0.2:1.8

m1Freqspace3, m2Freqspace3 = freqspaceM(10, dim = 2) # returns two -1:0.2:0.8

m1Freqspace4, m2Freqspace4 = freqspaceM(10, :meshgrid, dim = 2) # returns mesgridM(-1:0.2:0.8, -1:0.2:0.8), which is two -1:0.2:0.8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL576-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.horzcatM" href="#MatLang.horzcatM"><code>MatLang.horzcatM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">horzcatM(A1, A2, …)</code></pre><p>Concatenate arrays horizontally</p><p><strong>Examples</strong></p><pre><code class="language-julia">mHCat1 = horzcatM(ones(3, 3), zeros(3, 3)) # [ones(3, 3) zeros(3, 3)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL336-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.iscolumnM-Tuple{Any}" href="#MatLang.iscolumnM-Tuple{Any}"><code>MatLang.iscolumnM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iscolumnM(x)</code></pre><p>Returns boolean true if x is a column matrix.</p><p>Checks for being a column AbstractMatrix.</p><p>To get a MATLAB way result, pass <code>:mat</code> argument. Doing this:</p><ul><li>For arrays (of any element type), in addtion to column AbstractMatrices,  it also considers 1-dimensional arrays.</li><li>For others, if it is among <code>{Number, AbstractString, Char, Bool}</code>, then it is considered a column.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = [1; 2; 3] # or [1, 2, 3]
bIscolumn1 = iscolumnM(A1) # false

A2 = [1 2 3]
bIscolumn2 = iscolumnM(A2) # false

bIscolumn3 = iscolumnM(ones(3, 1)) # tue

bIscolumn4 = iscolumnM(ones(1, 3)) #false

bIscolumn5 = iscolumnM(ones(3)) # false

bIscolumn6 = iscolumnM(1) # false

bIscolumn7 = iscolumnM(&quot;Hi&quot;) # false

bIscolumn8 = iscolumnM([&quot;Hi&quot;, &quot;Bye&quot;]) # false

bIscolumn9 = iscolumnM([&quot;Hi&quot; &quot;Bye&quot;]) # false

# Matlab Way:
bIscolumnMat1 = iscolumnM(:mat, A1) # true

bIscolumnMat2 = iscolumnM(:mat, A2) # false

bIscolumnMat3 = iscolumnM(:mat, ones(3, 1)) # true

bIscolumnMat4 = iscolumnM(:mat, ones(1, 3)) # false

bIscolumnMat5 = iscolumnM(:mat, ones(3)) # true

bIscolumnMat6 = iscolumnM(:mat, 1) # true

bIscolumnMat7 = iscolumnM(:mat, &quot;Hi&quot;) # true

bIscolumnMat8 = iscolumnM(:mat, [&quot;Hi&quot;, &quot;Bye&quot;]) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL998-L1049">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.isemptyM" href="#MatLang.isemptyM"><code>MatLang.isemptyM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isempty(collection) -&gt; Bool</code></pre><p>Determine whether a collection is empty (has no elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</code></pre><pre><code class="language-none">isempty(condition)</code></pre><p>Return <code>true</code> if no tasks are waiting on the condition, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.ismatrixM-Tuple{Any}" href="#MatLang.ismatrixM-Tuple{Any}"><code>MatLang.ismatrixM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ismatrixM(x)</code></pre><p>Returns boolean true if x is a matrix.</p><p>It uses AbstractMatrix, which basically are two dimensional arrays.</p><p>To get a MATLAB way result, pass <code>:mat</code> argument. Doing this:</p><ul><li>For arrays (of any element type), it considers 1-dimensional arrays as matrix.</li><li>For others, if it is among <code>{Number, AbstractString, Char, Bool}</code>, then it is considered matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = [1 2 3; 3 5 6]
bIsMatrix1 = ismatrixM(A1) # true

A2 = [1;2;3] # or [1,2,3]
bIsMatrix2 = ismatrixM(A2) # false

bIsMatrix3 = ismatrixM(ones(3, 1)) # true

bIsMatrix4 = ismatrixM(ones(1, 3)) # true

bIsMatrix5 = ismatrixM(ones(3)) # false

bIsMatrix6 = ismatrixM(&quot;Hi&quot;) # false

bIsMatrix7 = ismatrixM([&quot;Hi&quot;, &quot;Bye&quot;]) # false

bIsMatrix8 = ismatrixM([&quot;Hi&quot; &quot;Bye&quot;]) # true

# Matlab Way:

bIsMatrixMat1 = ismatrixM(:mat, A1) # true

bIsMatrixMat2 = ismatrixM(:mat, A2) # true

bIsMatrixMat3 = ismatrixM(:mat, ones(3, 1)) # true

bIsMatrixMat4 = ismatrixM(:mat, ones(1, 3)) # true

bIsMatrixMat5 = ismatrixM(:mat, ones(3)) # true

bIsMatrixMat6 = ismatrixM(:mat, &quot;Hi&quot;) # true

bIsMatrixMat7 = ismatrixM(:mat, [&quot;Hi&quot;, &quot;Bye&quot;]) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL869-L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.isrowM-Tuple{Any}" href="#MatLang.isrowM-Tuple{Any}"><code>MatLang.isrowM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isrowM(x)</code></pre><p>Returns boolean true if x is a row matrix.</p><p>Checks for being a row AbstractMatrix.</p><p>To get a MATLAB way result, pass <code>:mat</code> argument. Doing this:</p><ul><li>For arrays (of any element type), same as Julia answer.</li><li>For others, if it is among <code>{Number, AbstractString, Char, Bool}</code>, then it is considered a row.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = [1; 2; 3] # or [1, 2, 3]
bIsrow1 = isrowM(A1) # false

A2 = [1 2 3]
bIsrow2 = isrowM(A2) # true

bIsrow3 = isrowM(ones(3, 1)) # false

bIsrow4 = isrowM(ones(1, 3)) # true

bIsrow5 = isrowM(ones(3)) # false

bIsrow6 = isrowM(1) # false

bIsrow7 = isrowM(&quot;Hi&quot;) # false

bIsrow8 = isrowM([&quot;Hi&quot;, &quot;Bye&quot;]) # false

bIsrow9 = isrowM([&quot;Hi&quot; &quot;Bye&quot;]) # true

# Matlab Way:
bIsrowMat1 = isrowM(:mat, A1) # false

bIsrowMat2 = isrowM(:mat, A2) # true

bIsrowMat3 = isrowM(:mat, ones(3, 1)) # false

bIsrowMat4 = isrowM(:mat, ones(1, 3)) # true

bIsrowMat5 = isrowM(:mat, ones(3)) # false

bIsrowMat6 = isrowM(:mat, 1) # true

bIsrowMat7 = isrowM(:mat, &quot;Hi&quot;) # true

bIsrowMat8 = isrowM(:mat, [&quot;Hi&quot;, &quot;Bye&quot;]) # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL932-L983">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.isscalarM-Union{Tuple{T}, Tuple{T}} where T" href="#MatLang.isscalarM-Union{Tuple{T}, Tuple{T}} where T"><code>MatLang.isscalarM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isscalarM(x)
isscalarM(:mat, x)</code></pre><p>Returns boolean true if x is scalar.</p><p>It uses <code>Broadcast.DefaultArrayStyle{0}</code>, which basically are numbers (0-dimensional) and 1 dimensional-1 element number arrays.</p><p>To get a MATLAB way result, pass <code>:mat</code> argument. Doing this:</p><ul><li>For arrays (of any element type), it calculates number of elements (using <code>numelM</code>).</li><li>For single strings it calculates number of characters (using <code>numelM</code>).</li><li>For others, if it is among <code>{Number,Char,Bool}</code>, then it is considered scalar.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">bIsscalar1 = isscalarM(1) # true

bIsscalar2 = isscalarM(5 * ones(1, 1, 1)) # false

# bIsscalar3 = isscalarM(&quot;H&quot;) # gives error
#
# bIsscalar4 = isscalarM(&quot;Hi&quot;) # gives error

bIsscalar5 = isscalarM([&quot;Hi&quot;]) # false

bIsscalar6 = isscalarM([&quot;Hi&quot; &quot;Bye&quot;]) # false

bIsscalar7 = isscalarM(&#39;H&#39;) # true # becareful that in Julia, chars are always singular.

bIsscalar8 = isscalarM(true) # true

# Matlab way:
bIsscalarMat1 = isscalarM(:mat, 1) # true

bIsscalarMat2 = isscalarM(:mat, [1]) # true

bIsscalarMat3 = isscalarM(:mat, 5 * ones(1, 1, 1)) # true

bIsscalarMat4 = isscalarM(:mat, &quot;H&quot;) # true

bIsscalarMat5 = isscalarM(:mat, &quot;Hi&quot;) # false

bIsscalarMat6 = isscalarM(:mat, [&quot;Hi&quot;]) # true

bIsscalarMat7 = isscalarM(:mat, [&quot;Hi&quot; &quot;Bye&quot;]) # false

bIsscalarMat8 = isscalarM(:mat, &#39;H&#39;) # true # becareful that in Julia, chars are always singular.

bIsscalarMat9 = isscalarM(:mat, true) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL731-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.isvectorM-Tuple{Any}" href="#MatLang.isvectorM-Tuple{Any}"><code>MatLang.isvectorM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isvectorM(x)</code></pre><p>Returns boolean true if x is a vector.</p><p>It uses AbstractVector, which basically are 1 dimensional arrays.</p><p>To get a MATLAB way result, pass <code>:mat</code> argument. Doing this:</p><ul><li>For arrays (of any element type), it considers 1-dimensional arrays and also 2-dimensional arrays that one of their dimensions are singletone.</li><li>For others, if it is among <code>{Number, AbstractString, Char, Bool}</code>, then it is considered matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = [1; 2; 3] # or [1, 2, 3]
bIsvector1 = isvectorM(A1) # true

A2 = [1 2 3]
bIsvector2 = isvectorM(A2) # false

bIsvector3 = isvectorM(ones(3, 1)) # false

bIsvector4 = isvectorM(ones(1, 3)) # false

bIsvector5 = isvectorM(ones(3)) # true

bIsvector6 = isvectorM(1) # false

bIsvector7 = isvectorM(&quot;Hi&quot;) # false

bIsvector8 = isvectorM([&quot;Hi&quot;, &quot;Bye&quot;]) # true

bIsMatrix9 = isvectorM([&quot;Hi&quot; &quot;Bye&quot;]) # false

# Matlab Way:
bIsvectorMat1 = isvectorM(:mat, A1) # true

bIsvectorMat2 = isvectorM(:mat, A2) # true

bIsvectorMat3 = isvectorM(:mat, ones(3, 1)) # true

bIsvectorMat4 = isvectorM(:mat, ones(1, 3)) # true

bIsvectorMat5 = isvectorM(:mat, ones(3)) # true

bIsvectorMat6 = isvectorM(:mat, 1) # true

bIsvectorMat7 = isvectorM(:mat, &quot;Hi&quot;) # true

bIsvectorMat8 = isvectorM(:mat, [&quot;Hi&quot;, &quot;Bye&quot;]) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL803-L854">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.lengthM-Tuple{AbstractArray}" href="#MatLang.lengthM-Tuple{AbstractArray}"><code>MatLang.lengthM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lengthM(A)</code></pre><p>Length of the largest array dimension of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = [2 3 4 5 6 7;
      1 2 3 4 5 6]
nLength1 = lengthM(A1); # 6

A2 = [&quot;Hi&quot; 6;
      &quot;Goodbye&quot; 5;
      &quot;Hello&quot; 1]
nLength2 = lengthM(A2); # 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL628-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.linspaceM-Tuple{Any,Any}" href="#MatLang.linspaceM-Tuple{Any,Any}"><code>MatLang.linspaceM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linspaceM(start, stop)
linspaceM(start, stop, step)
linspaceM(:arr, start, stop)
linspaceM(:arr, start, stop, step)</code></pre><p>Generate linearly spaced range. You can also write this as <code>start:stop</code> or <code>start:step:stop</code>.</p><p>To get the full vector isntead of a range object pass <code>:arr</code> as the 1st argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mLinspace1 = linspaceM(1, 10) # 1:10

mLinspace2 = linspaceM(1, 10, 2) # 1:2:10 == 1:2:9

mLinspace3 = linspaceM(:arr, 1, 10) # collect(1:10)

mLinspace4 = linspaceM(:arr, 1, 10, 2) # collect(1:2:10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL413-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.logspaceM-Tuple{Any,Any}" href="#MatLang.logspaceM-Tuple{Any,Any}"><code>MatLang.logspaceM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logspaceM(start, stop) # gives 50 points
logspaceM(start, stop, length)
logspaceM(start, stop, :equal) # equally spaced powers of 10</code></pre><p>Generate logarithmically spaced vector (between <code>10^start</code> and <code>10^stop</code>). <code>length</code> is the number of the poinst (50 by defualt if not supplied). If you instead provide <code>:equal</code>, it makes a range from equally spaced powers of 10</p><p>For <code>logspaceM</code> in contrast to <code>linspaceM</code>, the full vector is given by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mLogspace1 = logspaceM(1, 5) # 50 logarithmically spaced points between 10^1 and 10^5

mLogspace2 = logspaceM(1, 5, 10) # 10 logarithmically spaced points between 10^1 and 10^5

mLogspace3 = logspaceM(1, 5, :equal) # [10.0^1, 10.0^2, 10.0^3, 10.0^4, 10.0^5] == 10.0.^(1:5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL444-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.meshgridM-Tuple{AbstractArray{T,1} where T}" href="#MatLang.meshgridM-Tuple{AbstractArray{T,1} where T}"><code>MatLang.meshgridM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meshgridM(vx)
meshgridM(vx,vy)
meshgridM(vx,vy,vz)</code></pre><p>Creates a 2-dimensional or 3-dimensional rectangular grid, that spans the space made by it.</p><p><code>meshgridM(vx)</code> computes a 2-D (x,y)-grid from the vectors (vx,vx).</p><p><code>meshgridM(vx,vy)</code> computes a 2-D (x,y)-grid from the vectors (vx,vy).</p><p><code>meshgridM(vx,vy,vz)</code> computes a 3-D (x,y,z)-grid from the vectors (vx,vy,vz).</p><p>meshgridM&#39;s 1st output is the transpose of ngridsM&#39;s 1st output. It is the same for the 2nd output.</p><p>Modified from https://github.com/ChrisRackauckas/VectorizedRoutines.jl/blob/master/src/matlab.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia">m1Meshgrid0, m2Meshgrid0 = meshgridM(1:2:5) # a 2-D rectangle spanning 1:2:5 in x and y direction == [[1;1;1][3;3;3] [5;5;5]] and [1 1 1; 3 3 3; 5 5 5]

m1Meshgrid1, m2Meshgrid1 = meshgridM(1:2:5, 1:2:5) #  a 2-D rectangle spanning 1:2:5 in x and y direction == ([1 3 5;1 3 5; 1 3 5],[1 1 1; 3 3 3; 5 5 5])

m1Meshgrid2, m2Meshgrid2, m3Meshgrid2 = meshgridM(1:6, 20:25, 5:10) # a 3-D rectangle spanning 1:6 in x, 20:25 in y, and 5:10 in z</code></pre><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL472-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.ndgridM-Tuple{AbstractArray{T,1} where T}" href="#MatLang.ndgridM-Tuple{AbstractArray{T,1} where T}"><code>MatLang.ndgridM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngridM(x1, x2,...)
ngridM(x, dim = dimAsInteger)</code></pre><p>Creates a N-dimensional rectangular grid, that spans the space made by it.</p><p>In <code>ngridM(x1, x2,...)</code>, depending on the number of inputs, the dimension of output grid is specified.</p><p>In <code>ngridM(x, dim = dimAsInteger)</code>, user should explicitly pass the dimension as an integer to the function.</p><p>ngridsM&#39;s 1st output is the transpose of meshgridM()&#39;s 1st output. It is the same for the 2nd output.</p><p>Modified from https://github.com/ChrisRackauckas/VectorizedRoutines.jl/blob/master/src/matlab.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia">m1Ndgrid0, m2Ndgrid0 = ndgridM(1:2:5, dim = 2) # a 2-D rectangle spanning 1:2:5 in x and y direction == [1 1 1; 3 3 3; 5 5 5] and [1 3 5;1 3 5; 1 3 5]

m1Ndgrid1, m2Ndgrid1 = ndgridM(1:2:5, 1:2:5) #  a 2-D rectangle spanning 1:2:5 in x and y direction == ([1 1 1; 3 3 3; 5 5 5], [1 3 5;1 3 5; 1 3 5])

m1Ndgrid2, m2Ndgrid2, m3Ndgrid2 = ndgridM(1:6, 20:25, 5:10) # a 3-D rectangle spanning 1:6 in x, 20:25 in y, and 5:10 in z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL519-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.ndimsM" href="#MatLang.ndimsM"><code>MatLang.ndimsM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ndimsM(A)</code></pre><p>Return the number of dimensions of <code>A</code>.</p><p>In contrast to Matlab equivalent, this function considers trailing singleton dimensions,</p><p>Consider the points that are explained here when using this function: <a href="https://juliamatlab.github.io/MatLang/dev/juliavsmatlab/#Julia-Arrays:-1">Julia Arrays</a></p><p><strong>Examples</strong></p><pre><code class="language-julia">A = rand(3,4,5);
nDim1 = ndims(A) # 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL696-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.numelM" href="#MatLang.numelM"><code>MatLang.numelM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">numelM(A)</code></pre><p>Returns the number of elements of array <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">nNumel1 = numelM(1:5) # 5

nNumel2 = numelM([1, 2, 3, 4]) # 4

nNumel3 = numelM([1 2; 3 4]) # 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL714-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.onesM" href="#MatLang.onesM"><code>MatLang.onesM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">onesM</code></pre><p>returns an array filled with one values.</p><p>In addition to original Julia methods the following methods are provided:</p><pre><code class="language-none">onesM(..., like = anArray) # to make an array with similar type of anArray
onesM(Type, ...)           # to give type explicitly</code></pre><p>Above input arguments work with any other method.</p><pre><code class="language-none">onesM(sizeAsArray)</code></pre><p>To give size as an array (non-efficient Matlab way).</p><pre><code class="language-none">onesM(:mat, dim)         # square dim*dim matrix
onesM(:mat, Type, dim)   # square dim*dim matrix</code></pre><p><code>onesM(dim)</code> returns 1-dimensional array. To get a square matrix like in Matlab, pass <code>:mat</code> as the 1st argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mone0 = onesM(:mat, 2) # same as ones(2,2)

mone1 = onesM(:mat, 2, like = onesM(Int32, 2, 2)) # like method

A=[2 1 2]
mone2 = onesM(2, like=A) # same as ones(Int64,2)

mone3 = onesM(2) # same as ones(2)

mone4 = onesM(Int32, 2, 2) # same as ones(Int32,2,2)

# giving size as Tuple
mone5 = onesM((2, 2)) # = onesM(2,2)

mone6 = onesM(Int32, (2, 2))

# giving size as an Array
## non-efficient Matlab way. Array should be Integer otherwise you will get errors.

mone7 = onesM([2, 2])

mone8 = onesM(Int32, [2, 2])

mone9 = onesM([2, 2], like = [2.5 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL25-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.randM" href="#MatLang.randM"><code>MatLang.randM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randM</code></pre><p>returns an array filled with random values.</p><p>In addition to original Julia methods the following methods are provided:</p><pre><code class="language-none">randM(..., like = anArray) # to make an array with similar type of anArray
randM(Type, ...)           # to give type explicitly</code></pre><p>Above input arguments work with any other method.</p><pre><code class="language-none">randM(sizeAsArray)</code></pre><p>To give size as an array (non-efficient Matlab way).</p><pre><code class="language-none">randM(:mat, dim)         # square dim*dim matrix
randM(:mat, Type, dim)   # square dim*dim matrix</code></pre><p><code>randM(dim)</code> returns 1-dimensional array. To get a square matrix like in Matlab, pass <code>:mat</code> as the 1st argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mrandom0 = randM(:mat, 2) # same as rand(2,2)

mrandom1 = randM(:mat, 2, like = randM(Int32, 2, 2)) # like method

A=[2 1 2]
mrandom2 = randM(2, like=A) # same as rand(Int64,2)

mrandom3 = randM(2) # same as rand(2)

mrandom4 = randM(Int32, 2, 2) # same as rand(Int32,2,2)

# giving size as Tuple
mrandom5 = randM((2, 2)) # = randM(2,2)

mrandom6 = randM(Int32, (2, 2))

# giving size as an Array
## non-efficient Matlab way. Array should be Integer otherwise you will get errors.

mrandom7 = randM([2, 2])

mrandom8 = randM(Int32, [2, 2])

mrandom9 = randM([2, 2], like = [2.5 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL25-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.repelemM-Tuple{AbstractArray,Integer}" href="#MatLang.repelemM-Tuple{AbstractArray,Integer}"><code>MatLang.repelemM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">repelemM(V, count)</code></pre><p>Construct an array by repeating elements of array <code>V</code> by a given number of times specified by counts. if If count is a scalar, then each element of V is repeated <code>count</code> times</p><p><strong>Examples</strong></p><pre><code class="language-julia">V1 = [1 2 3 4];
mRepelem1 = repelemM(V1, 3) # [1 1 1 2 2 2 3 3 3 4 4 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL358-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.repmatM-Tuple{AbstractArray,Integer}" href="#MatLang.repmatM-Tuple{AbstractArray,Integer}"><code>MatLang.repmatM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">repmatM(A, n) # n*n copy
repmatM(A, s1, s2, ...)
repmatM(A, [s1, s2, ...])
repmatM(A, (s1, s2, ...))</code></pre><p>Repeat copies of array <code>A</code> based on the give size</p><p><strong>Examples</strong></p><pre><code class="language-julia">mRempat1 = repmatM(10, 3, 2) # [10 10; 10 10; 10 10]

V = [1; 2]
mRempat2 = repmatM(V, 3, 2)   # [[1; 2] [1; 2]; [1; 2] [1; 2]; [1; 2] [1; 2]]

mRempat3 = repmatM(V, [3, 2]) # [[1; 2] [1; 2]; [1; 2] [1; 2]; [1; 2] [1; 2]]

mRempat4 = repmatM(V, (3, 2)) # [[1; 2] [1; 2]; [1; 2] [1; 2]; [1; 2] [1; 2]]

mRempat5 = repmatM(V, 2) # [[1; 2] [1; 2]; [1; 2] [1; 2]]

mRempat6 = repmatM(V, 1, 3) # [[1; 2] [1; 2] [1; 2]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL378-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.rot90M" href="#MatLang.rot90M"><code>MatLang.rot90M</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rot90M(A)
rot90M(A, k)</code></pre><p>Rotate 90 or 90*k degress counter clock wise.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mRot1 = rot90M([1 2; 3 4]) #[2 4; 1 3]

mRot2 = rot90M([1 2; 3 4], 3) # [3 1; 4 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1213-L1225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.sizeM-Tuple" href="#MatLang.sizeM-Tuple"><code>MatLang.sizeM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sizeAsTuple = sizeM(A)
sizeDim = sizeM(dim)  # only returns the specified dim
sizeDimAsTuple = sizeM(A, dim1, dim2,...) # only returns the specified dims
sizeAsArray = sizeM(:arr, A)
sizeDimAsArray = sizeM(:arr, A, dim1, dim2,...) # only returns the specified dims
sz1, sz2, ... = size(A)</code></pre><p>Returns the size of an array as a Tuple.</p><p>Pass <code>:arr</code> to get size as an Array (not a Tuple).</p><p>Consider the points that are explained here when using this function: <a href="https://juliamatlab.github.io/MatLang/dev/juliavsmatlab/#Julia-Arrays:-1">Julia Arrays</a></p><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = [2 3 4 5 6 7;
      1 2 3 4 5 6]
mSize1 = sizeM(:arr, A1); # [2; 6]
tSize1 = sizeM(A1); # (2, 6)

nA1Size2 = sizeM(A1, 2); # 6
sizeM(A1, 2) == 6 # true
sizeM(:arr, A1, 2) == 6 # false
sizeM(:arr, A1, 2) == [6] # true

nA1Size1, nA1Size2 = sizeM(A1); # 2 and 6

A2 = rand(3, 5, 4)
mSize2 = sizeM(:arr, A2, 2, 3); # [5; 4]
tSize2 = sizeM(A2, 2, 3); # (5, 4)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL646-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.sortM-Tuple" href="#MatLang.sortM-Tuple"><code>MatLang.sortM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sortM(A)
sortM(A,dim)
sortM(..., direction)
sortM(..., I=true)</code></pre><p>Sorts array elements</p><p>If A is an matrix and dim not specified, it sorts each column. If A is an array, it sorts along first dimension</p><p>Optionally, specify direction as <code>:ascend</code> or <code>:descend</code>. Default one is <code>:ascend</code>.</p><p>If you want to get sort index as an output, you should pass <code>I=true</code>, as a keyword argument to the function. In this case sorted array is given as the first output using A[I]. This method is supported up to 2 dimensional matrices.</p><p>See <a href="functions/@ref"><code>sort</code></a> doc for more options.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mSort0 = sortM([5, 3, 19, 20, 1, 4]) # [1, 3, 4, 5, 19, 20]

A = [5, 3, 19, 20, 1, 4]
mSort1, iSort1 = sortM(A, I = true)  # returning sort index
A[iSort1] == mSort1

mSort2 = sortM([5, 3, 19, 20, 1, 4], :descend) # [20,19,5,4,3,1]

mSort3 = sortM([1 5 3; 4 1 10]) # [1 1 3; 4 5 10]

mSort4 = sortM([1 5 3; 4 1 10], 2, :ascend) # [1 3 5; 1 4 10]

B = [1 5 3; 4 1 10]
mSort5, iSort5 = sortM(B, 2, :ascend, I = true) # [1 3 5; 1 4 10]
B[iSort5] == mSort5

A = zerosM(Integer, 2, 2, 2)
A[:, :, 1] = [2 3; 1 6]
A[:, :, 2] = [-1 9; 0 12]
mSort6 = sortM(A, 3) # 3D sort</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1064-L1103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.squeezeM-Tuple{AbstractArray}" href="#MatLang.squeezeM-Tuple{AbstractArray}"><code>MatLang.squeezeM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squeezeM(A)</code></pre><p>Drops all of the singleton dimensions of <code>A</code> (dimensions that are 1). If <code>A</code> contains only one element (i.e., all of its dimensions are singletons) then the output will be a zero-dimensional array.</p><p>If you know the dimension that you want to drop, use dropdims(A ; dims= dimensionsToRemove).</p><p>Only use this function if you don&#39;t know the dimensions that you want to remove, and you are sure that you are not removing important dimensions, and if you don&#39;t care about type stability.</p><p>Returns an array containing the same data as <code>A</code> but with no singleton dimensions; note that the output is NOT a copy of <code>A</code>, i.e., modifying the contents of output will modify the contents of <code>A</code>. To get a copy use copy(output).</p><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = ones(2, 1, 2); # 3 dimensional
mSqueeze1 = squeezeM(A1) # [1 1; 1 1]

A2 = zeros(1, 4, 1);
A2[:, 1:4, ] = [5; 3; 6; 0]
mSqueeze2 = squeezeM(A2) # When it gets one dimensional, it is vertical.

mSqueeze2 == [5; 3; 6; 0] # true
mSqueeze2 == [5 3 6 0] # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1255-L1279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.transposeM-Tuple" href="#MatLang.transposeM-Tuple"><code>MatLang.transposeM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transposeM(A)
transposeM(:arr, A)</code></pre><p>Returns the transpose an array.</p><p>If <code>:arr</code> is supplied <code>permutedims</code> method is used which returns an array rather a transpose object.</p><p>You can use <code>&#39;</code> for transposing an Array (e.g <code>A&#39;</code>), the result is an adjoint object. If you want, you can get the array using <code>collect()</code>. Be careful that in Julia <code>.&#39;</code> is not used for transposing.</p><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = [2 3 4 5 6 7;
      1 2 3 4 5 6]
mTranspose1 = transposeM(A1)

mTranspose2 = transposeM(:arr, A1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL1228-L1246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.trueM" href="#MatLang.trueM"><code>MatLang.trueM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trueM</code></pre><p>returns an array filled with true values.</p><p>In addition to original Julia methods the following methods are provided:</p><pre><code class="language-none">trueM(sizeAsArray)</code></pre><p>To give size as an array (non-efficient Matlab way).</p><pre><code class="language-none">trueM(:mat, dim)         # square dim*dim matrix</code></pre><p><code>trueM(dim)</code> returns 1-dimensional array. To get a square matrix like in Matlab, pass <code>:mat</code> as the 1st argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mtrue0 = trueM(:mat, 2) # same as trues(2,2)

mtrue1 = trueM(2) # same as trues(2)

# giving size as Tuple
mtrue2 = trueM((2, 2)) # = trues(2,2)

# giving size as an Array
## non-efficient Matlab way. Array should be Integer otherwise you will get errors.
mtrue3 = trueM([2, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL127-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.vertcatM" href="#MatLang.vertcatM"><code>MatLang.vertcatM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertcatM(A1, A2, …)</code></pre><p>Concatenate arrays vertically</p><p><strong>Examples</strong></p><pre><code class="language-julia">mVCat1 = vertcatM(ones(3, 3), zeros(3, 3)) # [ones(3, 3); zeros(3, 3)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL347-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatLang.zerosM" href="#MatLang.zerosM"><code>MatLang.zerosM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zerosM</code></pre><p>returns an array filled with zero values.</p><p>In addition to original Julia methods the following methods are provided:</p><pre><code class="language-none">zerosM(..., like = anArray) # to make an array with similar type of anArray
zerosM(Type, ...)           # to give type explicitly</code></pre><p>Above input arguments work with any other method.</p><pre><code class="language-none">zerosM(sizeAsArray)</code></pre><p>To give size as an array (non-efficient Matlab way).</p><pre><code class="language-none">zerosM(:mat, dim)         # square dim*dim matrix
zerosM(:mat, Type, dim)   # square dim*dim matrix</code></pre><p><code>zerosM(dim)</code> returns 1-dimensional array. To get a square matrix like in Matlab, pass <code>:mat</code> as the 1st argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mzero0 = zerosM(:mat, 2) # same as zeros(2,2)

mzero1 = zerosM(:mat, 2, like = zerosM(Int32, 2, 2)) # like method

A=[2 1 2]
mzero2 = zerosM(2, like=A) # same as zeros(Int64,2)

mzero3 = zerosM(2) # same as zeros(2)

mzero4 = zerosM(Int32, 2, 2) # same as zeros(Int32,2,2)

# giving size as Tuple
mzero5 = zerosM((2, 2)) # = zerosM(2,2)

mzero6 = zerosM(Int32, (2, 2))

# giving size as an Array
## non-efficient Matlab way. Array should be Integer otherwise you will get errors.

mzero7 = zerosM([2, 2])

mzero8 = zerosM(Int32, [2, 2])

mzero9 = zerosM([2, 2], like = [2.5 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/c237f9219805a79a60ab60a7fdea29fd9f1fe90c/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL25-L73">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Entering_Commands/">« Entering Commands</a><a class="docs-footer-nextpage" href="../Numeric_Types/">Numeric Types »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 January 2020 18:21">Tuesday 14 January 2020</span>. Using Julia version 1.5.0-DEV.62.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
